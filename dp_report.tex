\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{amssymb}

\title{Minimum Camera Placement for Forest Monitoring -- DP Design}
\author{}
\date{}

\begin{document}
\maketitle

\section*{Problem}
We are given a forest graph $G=(V,E)$. Each vertex represents a candidate designated point (cdp) where we can place a camera, and each edge represents a shared region that can be monitored by cameras at two different cdps. The goal is to find the minimum number of cameras needed to monitor all vertices (regions).

This is the \emph{minimum dominating set} problem. While it is NP-hard for general graphs, it can be solved in polynomial time using dynamic programming (DP) for forest structures (trees). The following DP finds the optimum by rooting each tree.

\section*{DP Design}
\subsection*{1) Subproblems}
For each node $v$, we maintain three states (tree rooted at $r$):
\begin{itemize}
  \item $dp[v][0]$: Camera is placed at $v$.
  \item $dp[v][1]$: No camera at $v$, but at least one child has a camera and $v$ is dominated.
  \item $dp[v][2]$: No camera at $v$, $v$ is not yet dominated; domination must come from parent.
\end{itemize}

\subsection*{2) Recursive Formulation}
For a leaf node:
\[
dp[v][0]=1,\quad dp[v][1]=\infty,\quad dp[v][2]=0
\]

For an internal node $v$ with children set $C(v)$:
\[
dp[v][0] = 1 + \sum_{c \in C(v)} \min(dp[c][0], dp[c][1], dp[c][2])
\]
\[
dp[v][2] = \sum_{c \in C(v)} \min(dp[c][0], dp[c][1])
\]
In state $1$, $v$ must be dominated by at least one child camera:
\[
base = \sum_{c \in C(v)} \min(dp[c][0], dp[c][1])
\]
\[
dp[v][1] = 
\begin{cases}
\infty, & C(v)=\emptyset\\
base + \min_{c \in C(v)} \big( dp[c][0]-\min(dp[c][0], dp[c][1]) \big), & \text{otherwise}
\end{cases}
\]
This is because at least one child must actually have a camera (state $0$).

Valid answer for root: $\min(dp[r][0], dp[r][1])$ (root must be dominated).

\subsection*{3) Justification for DP}
\begin{itemize}
  \item Optimal substructure: The optimal solution for each subtree (child) is independent of others; combinations only interact through state labels.
  \item Number of subproblems: Constant number of states per node, total $O(|V|)$ subproblems.
  \item Overlapping subproblems: Each node's states cannot be requested by multiple parents (tree structure), so memoization with DP is efficient.
\end{itemize}

\subsection*{4) Pseudocode}
\begin{algorithm}[h]
\caption{MinCamerasOnTree($G$, $r$)}
\begin{algorithmic}[1]
\Function{Solve}{$v$, $parent$}
  \State $dp[v][0] \gets 1$ \Comment{Cost if camera placed at $v$}
  \State $dp[v][1] \gets \infty$ \Comment{Initially impossible}
  \State $dp[v][2] \gets 0$ \Comment{Cost if $v$ waits for parent}
  \For{child $c$ of $v$ where $c \neq parent$}
    \State \Call{Solve}{$c, v$} \Comment{Process children first}
  \EndFor
  \State $base \gets 0$, $gain \gets \infty$
  \For{child $c$ of $v$ where $c \neq parent$}
    \State $m02 \gets \min(dp[c][0], dp[c][1], dp[c][2])$ \Comment{Best for state 0}
    \State $m01 \gets \min(dp[c][0], dp[c][1])$ \Comment{Best for states 1 and 2}
    \State $dp[v][0] \gets dp[v][0] + m02$
    \State $dp[v][2] \gets dp[v][2] + m01$
    \State $base \gets base + m01$
    \State $gain \gets \min(gain, dp[c][0]-m01)$ \Comment{Extra cost to force state 0}
  \EndFor
  \If{$gain < \infty$}
    \State $dp[v][1] \gets base + gain$ \Comment{At least one child has camera}
  \EndIf
\EndFunction
\State \Call{Solve}{$r, -1$}
\State \Return $\min(dp[r][0], dp[r][1])$ \Comment{Root must be dominated}
\end{algorithmic}
\end{algorithm}

\subsection*{Time Complexity (Task 2)}
Let $n = |V|$ and $m = |E|$. Each edge is visited at most twice during the DFS, and per node we do $O(1)$ work for constant-state DP aggregation. Thus the time complexity is $O(n + m)$ in the worst case (for trees, $m = n - 1$, so $O(n)$). The space complexity is $O(n)$ for the DP tables and recursion stack.

\subsection*{Step-by-Step Example (Task 3)}
Consider a sample tree with 5 cdps (nodes) where each cdp monitors 2--3 regions: edges $\{(0,1), (1,2), (1,3), (3,4)\}$ and root at $1$.
\begin{itemize}
  \item Post-order traversal: process children before parent.
  \item Node 0 (leaf): $dp[0] = [1, \infty, 0]$.
  \item Node 2 (leaf): $dp[2] = [1, \infty, 0]$.
  \item Node 4 (leaf): $dp[4] = [1, \infty, 0]$.
  \item Node 3 (child 4): 
    \begin{itemize}
      \item $dp[3][0] = 1 + \min(1, \infty, 0) = 1$
      \item $dp[3][2] = \min(1, \infty) = 1$
      \item $dp[3][1] = base + gain = 1 + (1 - 1) = 1$ (force child 4 to have camera)
    \end{itemize}
    So $dp[3] = [1, 1, 1]$.
  \item Node 1 (children 0,2,3):
    \begin{itemize}
      \item For child 0: $m02 = 1, m01 = 1$.
      \item For child 2: $m02 = 1, m01 = 1$.
      \item For child 3: $m02 = 1, m01 = 1$.
    \end{itemize}
    Aggregate:
    \begin{align*}
    dp[1][0] &= 1 + (1+1+1) = 4\\
    dp[1][2] &= 1 + 1 + 1 = 3\\
    base &= 3,\quad gain = \min(0,0,0)=0\\
    dp[1][1] &= 3 + 0 = 3
    \end{align*}
  \item Answer at root 1: $\min(dp[1][0], dp[1][1]) = \min(4,3) = 3$ cameras.
\end{itemize}
Placement achieving 3 cameras: cameras at nodes $\{0,3,1\}$ (or any equivalent minimum set).

\end{document}
